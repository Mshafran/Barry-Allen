// Team Barry-Allen -- Ryan Siu, Edwin Mok, Mark Shafran
// APCS2 pd5
// Lab 01 -- What Does the Data Say?
// 2017-03-09

/*======================================
  class QuickjortTester

  TIMING MECHANISM:
  Our timing mechanism works by going through an array of specificed n-values,
    recording the average time of the sorts on randomly-generated arrays of 
    each n-value, and printing the n-values and their corresponding times in a 
    neat format once all the sorts are finished. We used a batch size of 100 in
    order to ensure that outliers don't affect the time of the sort, and we 
    made sure to eliminate as much "noise" from the results as possible by only
    measuring the time it takes to run the qsort method. Additionally, the O(n)
    and O(n^2) methods that were written for reference simply perform O(1) 
    operations on randomly-generated arrays n and n^2 times, correspondingly.
  ======================================*/

public class QuickSortTester 
{
    
    public static final int[] NUMS = {1,10,100,1000,5000,10000,50000,100000,500000,1000000,2500000,5000000,7500000,10000000};
	
    /******************************
     * execution time analysis
     * Random arrays are generated by producing arrays of n length, with each
     * element inside being an random integer from 0 to n.
     ******************************/
    public static void main( String[] args ) 
    {
	String retStr = "";

	// run all the n's at once
	for (int j = 0; j < NUMS.length; j++) {
	    
	    int n = NUMS[j];        // number of elements to be generated
	    int batchSize = 100;    // number of times to repeat operation
	    double sum = 0;         // for calculating average of runtime

	    // repeat batchSize times
	    for (int times = 0; times < batchSize; times++) {
	
		// generate array with random ints from 0 to n
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
		    arr[i] = (int)(Math.random()*n);
		}

		// begin sort
		long startTime = System.currentTimeMillis();
		QuickSort.qsort(arr);
		long elapsedTime = System.currentTimeMillis() - startTime;

		// O(n) operation for time reference
		/*
		long startTime = System.currentTimeMillis();
	        for (int t = 0; t < n; t++) {
		    arr[t]++;
		}
		long elapsedTime = System.currentTimeMillis() - startTime;
		*/

		// O(n^2) operation for time reference
		/*
		long startTime = System.currentTimeMillis();
	        for (int t = 0; t < n; t++) {
		    for (int u = 0; u < n; u++) {
			arr[u]++;
		    }
		}
		long elapsedTime = System.currentTimeMillis() - startTime;
		*/
	    
		System.out.print( "Runtime Quick Sort " + (times+1) + " : " );
		System.out.println( elapsedTime );
		sum += elapsedTime;
	    }

	    retStr += NUMS[j] + "," + sum / batchSize + ",\n";

	    // print average
	    System.out.println( sum / batchSize );
	    
	}

	// prints times in a readable format
	System.out.println( retStr );
	
    }//end main

}//end class
